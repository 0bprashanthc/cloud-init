Author: Ben Howard <ben.howard.@ubuntu.com>
Bug: https://launchpad.net/bugs/1231490
Applied-Upstream: yes
Description: Changes to cc_mounts.py to support Bugs 123315 and 1231490. This
 adds support for referening devices as 'ephemeral0.x', where X is a
 partition number, 'auto', or 'any'.
--- a/cloudinit/CloudConfig/cc_mounts.py
+++ b/cloudinit/CloudConfig/cc_mounts.py
@@ -18,10 +18,23 @@
 #    You should have received a copy of the GNU General Public License
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-import cloudinit.util as util
+from string import whitespace  # pylint: disable=W0402
+
+import logging
 import os
+import os.path
 import re
-from string import whitespace  # pylint: disable=W0402
+
+from cloudinit import future_util as futil
+from cloudinit import util
+
+# Shortname matches 'sda', 'sda1', 'xvda', 'hda', 'sdb', xvdb, vda, vdd1, sr0
+SHORTNAME_FILTER = r"^([x]{0,1}[shv]d[a-z][0-9]*|sr[0-9]+)$"
+SHORTNAME = re.compile(SHORTNAME_FILTER)
+WS = re.compile("[%s]+" % (whitespace))
+FSTAB_PATH = "/etc/fstab"
+
+LOG = logging.getLogger(__name__)
 
 
 def is_mdname(name):
@@ -36,6 +49,33 @@ def is_mdname(name):
     return False
 
 
+def sanitize_devname(startname, transformer, log):
+    log.debug("Attempting to determine the real name of %s", startname)
+
+    # workaround, allow user to specify 'ephemeral'
+    # rather than more ec2 correct 'ephemeral0'
+    devname = startname
+    if devname == "ephemeral":
+        devname = "ephemeral0"
+        log.debug("Adjusted mount option from ephemeral to ephemeral0")
+
+    (blockdev, part) = futil.expand_dotted_devname(devname)
+
+    if is_mdname(blockdev):
+        orig = blockdev
+        blockdev = transformer(blockdev)
+        if not blockdev:
+            return None
+        if not blockdev.startswith("/"):
+            blockdev = "/dev/%s" % blockdev
+        log.debug("Mapped metadata name %s to %s", orig, blockdev)
+    else:
+        if SHORTNAME.match(startname):
+            blockdev = "/dev/%s" % blockdev
+
+    return devnode_for_dev_part(blockdev, part)
+
+
 def handle(_name, cfg, cloud, log, _args):
     # fs_spec, fs_file, fs_vfstype, fs_mntops, fs-freq, fs_passno
     defvals = [None, None, "auto", "defaults,nobootwait", "0", "2"]
@@ -49,38 +89,29 @@ def handle(_name, cfg, cloud, log, _args
     if "mounts" in cfg:
         cfgmnt = cfg["mounts"]
 
-    # shortname matches 'sda', 'sda1', 'xvda', 'hda', 'sdb', xvdb, vda, vdd1
-    shortname_filter = r"^[x]{0,1}[shv]d[a-z][0-9]*$"
-    shortname = re.compile(shortname_filter)
-
     for i in range(len(cfgmnt)):
         # skip something that wasn't a list
         if not isinstance(cfgmnt[i], list):
+            log.warn("Mount option %s not a list, got a %s instead",
+                     (i + 1), futils.type_utils_obj_name(cfgmnt[i]))
             continue
 
-        # workaround, allow user to specify 'ephemeral'
-        # rather than more ec2 correct 'ephemeral0'
-        if cfgmnt[i][0] == "ephemeral":
-            cfgmnt[i][0] = "ephemeral0"
-
-        if is_mdname(cfgmnt[i][0]):
-            newname = cloud.device_name_to_device(cfgmnt[i][0])
-            if not newname:
-                log.debug("ignoring nonexistant named mount %s" % cfgmnt[i][0])
-                cfgmnt[i][1] = None
-            else:
-                if newname.startswith("/"):
-                    cfgmnt[i][0] = newname
-                else:
-                    cfgmnt[i][0] = "/dev/%s" % newname
-        else:
-            if shortname.match(cfgmnt[i][0]):
-                cfgmnt[i][0] = "/dev/%s" % cfgmnt[i][0]
+        start = str(cfgmnt[i][0])
+        sanitized = sanitize_devname(start, cloud.device_name_to_device, log)
+        if sanitized is None:
+            log.debug("Ignorming nonexistant named mount %s", start)
+            continue
+
+        if sanitized != start:
+            log.debug("changed %s => %s" % (start, sanitized))
+        cfgmnt[i][0] = sanitized
 
         # in case the user did not quote a field (likely fs-freq, fs_passno)
         # but do not convert None to 'None' (LP: #898365)
         for j in range(len(cfgmnt[i])):
-            if isinstance(cfgmnt[i][j], int):
+            if cfgmnt[i][j] is None:
+                continue
+            else:
                 cfgmnt[i][j] = str(cfgmnt[i][j])
 
     for i in range(len(cfgmnt)):
@@ -102,13 +133,14 @@ def handle(_name, cfg, cloud, log, _args
     # for each of the "default" mounts, add them only if no other
     # entry has the same device name
     for defmnt in defmnts:
-        devname = cloud.device_name_to_device(defmnt[0])
-        if devname is None:
+        start = defmnt[0]
+        sanitized = sanitize_devname(start, cloud.device_name_to_device, log)
+        if sanitized is None:
+            log.debug("Ignoring nonexistant default named mount %s", start)
             continue
-        if devname.startswith("/"):
-            defmnt[0] = devname
-        else:
-            defmnt[0] = "/dev/%s" % devname
+        if sanitized != start:
+            log.debug("changed default device %s => %s" % (start, sanitized))
+        defmnt[0] = sanitized
 
         cfgmnt_has = False
         for cfgm in cfgmnt:
@@ -117,14 +149,22 @@ def handle(_name, cfg, cloud, log, _args
                 break
 
         if cfgmnt_has:
+            log.debug(("Not including %s, already"
+                       " previously included"), start)
             continue
         cfgmnt.append(defmnt)
 
     # now, each entry in the cfgmnt list has all fstab values
     # if the second field is None (not the string, the value) we skip it
-    actlist = [x for x in cfgmnt if x[1] is not None]
+    actlist = []
+    for x in cfgmnt:
+        if x[1] is None:
+            log.debug("Skipping non-existent device named %s", x[0])
+        else:
+            actlist.append(x)
 
     if len(actlist) == 0:
+        log.debug("No modifications to fstab needed.")
         return
 
     comment = "comment=cloudconfig"
@@ -133,7 +173,7 @@ def handle(_name, cfg, cloud, log, _args
     dirs = []
     for line in actlist:
         # write 'comment' in the fs_mntops, entry,  claiming this
-        line[3] = "%s,comment=cloudconfig" % line[3]
+        line[3] = "%s,%s" % (line[3], comment)
         if line[2] == "swap":
             needswap = True
         if line[1].startswith("/"):
@@ -141,11 +181,9 @@ def handle(_name, cfg, cloud, log, _args
         cc_lines.append('\t'.join(line))
 
     fstab_lines = []
-    fstab = open("/etc/fstab", "r+")
-    ws = re.compile("[%s]+" % whitespace)
-    for line in fstab.read().splitlines():
+    for line in util.load_file(FSTAB_PATH).splitlines():
         try:
-            toks = ws.split(line)
+            toks = WS.split(line)
             if toks[3].find(comment) != -1:
                 continue
         except:
@@ -153,27 +191,70 @@ def handle(_name, cfg, cloud, log, _args
         fstab_lines.append(line)
 
     fstab_lines.extend(cc_lines)
-
-    fstab.seek(0)
-    fstab.write("%s\n" % '\n'.join(fstab_lines))
-    fstab.truncate()
-    fstab.close()
+    contents = "%s\n" % ('\n'.join(fstab_lines))
+    util.write_file(FSTAB_PATH, contents)
 
     if needswap:
         try:
-            util.subp(("swapon", "-a"))
+            futil.subp(("swapon", "-a"))
         except:
-            log.warn("Failed to enable swap")
+            log.warn("Activating swap via 'swapon -a' failed")
 
     for d in dirs:
-        if os.path.exists(d):
-            continue
         try:
-            os.makedirs(d)
+            if not os.path.isdir(d):
+                os.makedirs(d)
         except:
-            log.warn("Failed to make '%s' config-mount\n", d)
+            log.warn("Failed to make '%s' config-mount", d)
 
     try:
-        util.subp(("mount", "-a"))
+        futil.subp(("mount", "-a"))
     except:
-        log.warn("'mount -a' failed")
+        log.warn("Activating mounts via 'mount -a' failed")
+
+
+def devnode_for_dev_part(device, partition):
+    """
+    Find the name of the partition. While this might seem rather
+    straight forward, its not since some devices are '<device><partition>'
+    while others are '<device>p<partition>'. For example, /dev/xvda3 on EC2
+    will present as /dev/xvda3p1 for the first partition since /dev/xvda3 is
+    a block device.
+    """
+    if not os.path.exists(device):
+        return None
+
+    short_name = os.path.basename(device)
+    sys_path = "/sys/block/%s" % short_name
+
+    if not os.path.exists(sys_path):
+        LOG.debug("did not find entry for %s in /sys/block", short_name)
+        return None
+
+    sys_long_path = sys_path + "/" + short_name
+
+    if partition is not None:
+        partition = str(partition)
+
+    if partition is None:
+        valid_mappings = [sys_long_path + "1",
+                          sys_long_path + "p1"]
+    elif partition != "0":
+        valid_mappings = [sys_long_path + "%s" % partition,
+                          sys_long_path + "p%s" % partition]
+    else:
+        valid_mappings = []
+
+    for cdisk in valid_mappings:
+        if not os.path.exists(cdisk):
+            continue
+
+        dev_path = "/dev/%s" % os.path.basename(cdisk)
+        if os.path.exists(dev_path):
+            return dev_path
+
+    if partition is None or partition == "0":
+        return device
+
+    LOG.debug("Did not fine partition %s for device %s", partition, device)
+    return None
--- a/cloudinit/future_util.py
+++ b/cloudinit/future_util.py
@@ -1,6 +1,7 @@
 import logging
 import os.path
 import subprocess
+import types
 
 LOG = logging.getLogger(__name__)
 
@@ -146,3 +147,9 @@ def expand_dotted_devname(dotted):
         return (dotted, None)
 
 
+def type_utils_obj_name(obj):
+    if isinstance(obj, (types.TypeType,
+                        types.ModuleType,
+                        types.FunctionType,
+                        types.LambdaType)):
+        return str(obj.__name__)
