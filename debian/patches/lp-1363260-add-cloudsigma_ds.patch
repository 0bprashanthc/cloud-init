Author: Ben Howard <ben.howard@ubuntu.com>
Bug: https://launchpad.net/bugs/1363260
Applied-Upstream: yes
Description: Backport of 14.04/14.10 CloudSigma datasource
--- /dev/null
+++ b/cloudinit/cs_utils.py
@@ -0,0 +1,105 @@
+# vi: ts=4 expandtab
+#
+#    Copyright (C) 2014 CloudSigma
+#
+#    Author: Kiril Vladimiroff <kiril.vladimiroff@cloudsigma.com>
+#
+#    This program is free software: you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 3, as
+#    published by the Free Software Foundation.
+#
+#    This program is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+"""
+cepko implements easy-to-use communication with CloudSigma's VMs through
+a virtual serial port without bothering with formatting the messages
+properly nor parsing the output with the specific and sometimes
+confusing shell tools for that purpose.
+
+Having the server definition accessible by the VM can ve useful in various
+ways. For example it is possible to easily determine from within the VM,
+which network interfaces are connected to public and which to private network.
+Another use is to pass some data to initial VM setup scripts, like setting the
+hostname to the VM name or passing ssh public keys through server meta.
+
+For more information take a look at the Server Context section of CloudSigma
+API Docs: http://cloudsigma-docs.readthedocs.org/en/latest/server_context.html
+"""
+import json
+import platform
+
+import serial
+
+# these high timeouts are necessary as read may read a lot of data.
+READ_TIMEOUT = 60
+WRITE_TIMEOUT = 10
+
+SERIAL_PORT = '/dev/ttyS1'
+if platform.system() == 'Windows':
+    SERIAL_PORT = 'COM2'
+
+
+class Cepko(object):
+    """
+    One instance of that object could be use for one or more
+    queries to the serial port.
+    """
+    request_pattern = "<\n{}\n>"
+
+    def get(self, key="", request_pattern=None):
+        if request_pattern is None:
+            request_pattern = self.request_pattern
+        return CepkoResult(request_pattern.format(key))
+
+    def all(self):
+        return self.get()
+
+    def meta(self, key=""):
+        request_pattern = self.request_pattern.format("/meta/{}")
+        return self.get(key, request_pattern)
+
+    def global_context(self, key=""):
+        request_pattern = self.request_pattern.format("/global_context/{}")
+        return self.get(key, request_pattern)
+
+
+class CepkoResult(object):
+    """
+    CepkoResult executes the request to the virtual serial port as soon
+    as the instance is initialized and stores the result in both raw and
+    marshalled format.
+    """
+    def __init__(self, request):
+        self.request = request
+        self.raw_result = self._execute()
+        self.result = self._marshal(self.raw_result)
+
+    def _execute(self):
+        connection = serial.Serial(port=SERIAL_PORT,
+                                   timeout=READ_TIMEOUT,
+                                   writeTimeout=WRITE_TIMEOUT)
+        connection.write(self.request)
+        return connection.readline().strip('\x04\n')
+
+    def _marshal(self, raw_result):
+        try:
+            return json.loads(raw_result)
+        except ValueError:
+            return raw_result
+
+    def __len__(self):
+        return self.result.__len__()
+
+    def __getitem__(self, key):
+        return self.result.__getitem__(key)
+
+    def __contains__(self, item):
+        return self.result.__contains__(item)
+
+    def __iter__(self):
+        return self.result.__iter__()
--- /dev/null
+++ b/cloudinit/DataSourceCloudSigma.py
@@ -0,0 +1,144 @@
+# vi: ts=4 expandtab
+#
+#    Copyright (C) 2014 CloudSigma
+#
+#    Author: Kiril Vladimiroff <kiril.vladimiroff@cloudsigma.com>
+#
+#    This program is free software: you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 3, as
+#    published by the Free Software Foundation.
+#
+#    This program is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+from base64 import b64decode
+import logging
+import os
+import re
+
+from cloudinit import DataSource as sources
+from cloudinit import future_util as futil
+from cloudinit.cs_utils import Cepko
+
+LOG = logging.getLogger(__name__)
+
+VALID_DSMODES = ("local", "net", "disabled")
+
+
+class DataSourceCloudSigma(sources.DataSource):
+    """
+    Uses cepko in order to gather the server context from the VM.
+
+    For more information about CloudSigma's Server Context:
+    http://cloudsigma-docs.readthedocs.org/en/latest/server_context.html
+    """
+    def __init__(self, sys_cfg):
+        sources.DataSource.__init__(self, sys_cfg)
+        self.dsmode = 'local'
+        self.cepko = Cepko()
+        self.ssh_public_key = ''
+
+    def is_running_in_cloudsigma(self):
+        """
+        Uses dmidecode to detect if this instance of cloud-init is running
+        in the CloudSigma's infrastructure.
+        """
+        uname_arch = os.uname()[4]
+        if uname_arch.startswith("arm") or uname_arch == "aarch64":
+            # Disabling because dmidecode in CMD_DMI_SYSTEM crashes kvm process
+            LOG.debug("Disabling CloudSigma datasource on arm (LP: #1243287)")
+            return False
+
+        dmidecode_path = futil.which('dmidecode')
+        if not dmidecode_path:
+            return False
+
+        LOG.debug("Determining hypervisor product name via dmidecode")
+        try:
+            cmd = [dmidecode_path, "--string", "system-product-name"]
+            system_product_name, _ = futil.subp(cmd)
+            return 'cloudsigma' in system_product_name.lower()
+        except:
+            LOG.warn("Failed to get hypervisor product name via dmidecode")
+
+        return False
+
+    def get_data(self):
+        """
+        Metadata is the whole server context and /meta/cloud-config is used
+        as userdata.
+        """
+        dsmode = None
+        if not self.is_running_in_cloudsigma():
+            return False
+
+        try:
+            server_context = self.cepko.all().result
+            server_meta = server_context['meta']
+        except:
+            # TODO: check for explicit "config on", and then warn
+            # but since no explicit config is available now, just debug.
+            LOG.debug("CloudSigma: Unable to read from serial port")
+            return False
+
+        dsmode = server_meta.get('cloudinit-dsmode', self.dsmode)
+        if dsmode not in VALID_DSMODES:
+            LOG.warn("Invalid dsmode %s, assuming default of 'net'", dsmode)
+            dsmode = 'net'
+        if dsmode == "disabled" or dsmode != self.dsmode:
+            return False
+
+        base64_fields = server_meta.get('base64_fields', '').split(',')
+        self.userdata_raw = server_meta.get('cloudinit-user-data', "")
+        if 'cloudinit-user-data' in base64_fields:
+            self.userdata_raw = b64decode(self.userdata_raw)
+
+        # Disabled VendorData as not supported yet on 12.04
+        #if 'cloudinit' in server_context.get('vendor_data', {}):
+        #    self.vendordata_raw = server_context["vendor_data"]["cloudinit"]
+
+        self.metadata = server_context
+        self.ssh_public_key = server_meta['ssh_public_key']
+
+        return True
+
+    def get_hostname(self, fqdn=False, resolve_ip=False):
+        """
+        Cleans up and uses the server's name if the latter is set. Otherwise
+        the first part from uuid is being used.
+        """
+        if re.match(r'^[A-Za-z0-9 -_\.]+$', self.metadata['name']):
+            return self.metadata['name'][:61]
+        else:
+            return self.metadata['uuid'].split('-')[0]
+
+    def get_public_ssh_keys(self):
+        return [self.ssh_public_key]
+
+    def get_instance_id(self):
+        return self.metadata['uuid']
+
+
+class DataSourceCloudSigmaNet(DataSourceCloudSigma):
+    def __init__(self, sys_cfg):
+        DataSourceCloudSigma.__init__(self, sys_cfg)
+        self.dsmode = 'net'
+
+
+# Used to match classes to dependencies. Since this datasource uses the serial
+# port network is not really required, so it's okay to load without it, too.
+datasources = [
+    (DataSourceCloudSigma, (sources.DEP_FILESYSTEM)),
+    (DataSourceCloudSigmaNet, (sources.DEP_FILESYSTEM, sources.DEP_NETWORK)),
+]
+
+
+def get_datasource_list(depends):
+    """
+    Return a list of data sources that match this set of dependencies
+    """
+    return sources.list_from_depends(depends, datasources)
